<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/org/paper/controllers/UsuarioController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/paper/controllers/UsuarioController.java" />
              <option name="originalContent" value="package org.paper.controllers;&#10;&#10;import org.paper.DTO.UsuarioDTO;&#10;import org.paper.services.UsuarioService;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/usuarios&quot;)&#10;public class UsuarioController {&#10;&#10;    private final UsuarioService usuarioService;&#10;&#10;    public UsuarioController(UsuarioService usuarioService) {&#10;        this.usuarioService = usuarioService;&#10;    }&#10;&#10;    @PostMapping(&quot;/crear&quot;)&#10;    public ResponseEntity&lt;String&gt; crearUsuario(@RequestBody UsuarioDTO usuario) {&#10;        return usuarioService.crearUsuario(usuario);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/eliminar/{username}&quot;)&#10;    public ResponseEntity&lt;String&gt; eliminarUsuario(@PathVariable String username) {&#10;        return usuarioService.eliminarUsuario(username);&#10;    }&#10;&#10;    @GetMapping&#10;    public ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; listarUsuarios() {&#10;        return usuarioService.listarUsuarios();&#10;    }&#10;&#10;&#10;}" />
              <option name="updatedContent" value="package org.paper.controllers;&#10;&#10;import org.paper.DTO.UsuarioDTO;&#10;import org.paper.services.UsuarioService;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;import java.util.List;&#10;import java.util.Map;&#10;&#10;@RestController&#10;@RequestMapping(&quot;/api/usuarios&quot;)&#10;public class UsuarioController {&#10;&#10;    private final UsuarioService usuarioService;&#10;&#10;    public UsuarioController(UsuarioService usuarioService) {&#10;        this.usuarioService = usuarioService;&#10;    }&#10;&#10;    @PostMapping(&quot;/crear&quot;)&#10;    public ResponseEntity&lt;String&gt; crearUsuario(@RequestBody UsuarioDTO usuario) {&#10;        return usuarioService.crearUsuario(usuario);&#10;    }&#10;&#10;    @DeleteMapping(&quot;/eliminar/{username}&quot;)&#10;    public ResponseEntity&lt;String&gt; eliminarUsuario(@PathVariable String username) {&#10;        return usuarioService.eliminarUsuario(username);&#10;    }&#10;&#10;    @GetMapping&#10;    public ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; listarUsuarios() {&#10;        return usuarioService.listarUsuarios();&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/org/paper/services/UsuarioService.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/org/paper/services/UsuarioService.java" />
              <option name="originalContent" value="package org.paper.services;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import org.paper.DTO.UsuarioDTO;&#10;import org.paper.entity.Usuario;&#10;import org.paper.repository.UsuarioRepository;&#10;import org.springframework.core.ParameterizedTypeReference;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;&#10;@Slf4j&#10;@Service&#10;public class UsuarioService {&#10;&#10;    private final KeycloakAdminService keycloakAdminService;&#10;    private final UsuarioRepository usuarioRepository;&#10;    private final WebClient webClient;&#10;&#10;    public UsuarioService(KeycloakAdminService keycloakAdminService,&#10;                          UsuarioRepository usuarioRepository,&#10;                          WebClient webClient) {&#10;        this.keycloakAdminService = keycloakAdminService;&#10;        this.usuarioRepository = usuarioRepository;&#10;        this.webClient = webClient;&#10;    }&#10;&#10;    @Transactional&#10;    public ResponseEntity&lt;String&gt; crearUsuario(UsuarioDTO usuario) {&#10;        String token = keycloakAdminService.getAdminToken();&#10;        String userId = null;&#10;&#10;        try {&#10;            // 1. Crear usuario en Keycloak&#10;            String jsonBody = String.format(&#10;                    &quot;{ \&quot;username\&quot;:\&quot;%s\&quot;, \&quot;enabled\&quot;:%b, \&quot;firstName\&quot;:\&quot;%s\&quot;, \&quot;lastName\&quot;:\&quot;%s\&quot;, \&quot;email\&quot;:\&quot;%s\&quot;, \&quot;emailVerified\&quot;:%b }&quot;,&#10;                    usuario.getUsername(),&#10;                    usuario.isEnabled(),&#10;                    usuario.getFirstName(),&#10;                    usuario.getLastName(),&#10;                    usuario.getEmail(),&#10;                    usuario.isEmailVerified()&#10;            );&#10;&#10;            ResponseEntity&lt;String&gt; response = webClient.post()&#10;                    .uri(&quot;/admin/realms/tesina/users&quot;)&#10;                    .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                    .contentType(MediaType.APPLICATION_JSON)&#10;                    .bodyValue(jsonBody)&#10;                    .retrieve()&#10;                    .toEntity(String.class)&#10;                    .block();&#10;&#10;            if (response.getStatusCode().is2xxSuccessful()) {&#10;                // 2. Obtener UUID&#10;                userId = obtenerUserId(usuario.getUsername(), token);&#10;                if (userId == null) throw new RuntimeException(&quot;No se pudo obtener el UUID de Keycloak&quot;);&#10;&#10;                // 3. Asignar password&#10;                if (usuario.getPassword() != null) {&#10;                    try {&#10;                        asignarPassword(usuario, token, userId);&#10;                    } catch (Exception e) {&#10;                        eliminarUsuarioEnKeycloak(userId, token);&#10;                        throw new RuntimeException(&quot;Fallo asignando password: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                // 4. Guardar en Postgres (protegido por @Transactional)&#10;                Usuario entity = new Usuario();&#10;                entity.setId(UUID.fromString(userId));&#10;                entity.setFechaRegistro(LocalDateTime.now());&#10;                usuarioRepository.save(entity);&#10;&#10;                // 5. Asignar rol por defecto (INTERESADO)&#10;                try {&#10;                    asignarRol(userId, &quot;INTERESADO&quot;, token);&#10;                } catch (Exception e) {&#10;                    eliminarUsuarioEnKeycloak(userId, token);&#10;                    throw new RuntimeException(&quot;Fallo asignando rol: &quot; + e.getMessage());&#10;                }&#10;&#10;            } else {&#10;                throw new RuntimeException(&quot;Error al crear usuario en Keycloak: &quot; + response.getStatusCode());&#10;            }&#10;&#10;            return ResponseEntity.ok(&quot;Usuario creado correctamente&quot;);&#10;&#10;        } catch (Exception e) {&#10;            if (userId != null) {&#10;                eliminarUsuarioEnKeycloak(userId, token);&#10;            }&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Error al crear usuario: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void asignarPassword(UsuarioDTO usuario, String token, String userId) {&#10;        String passwordJson = String.format(&quot;{\&quot;type\&quot;:\&quot;password\&quot;,\&quot;value\&quot;:\&quot;%s\&quot;,\&quot;temporary\&quot;:false}&quot;, usuario.getPassword());&#10;&#10;        webClient.put()&#10;                .uri(&quot;/admin/realms/tesina/users/{id}/reset-password&quot;, userId)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .contentType(MediaType.APPLICATION_JSON)&#10;                .bodyValue(passwordJson)&#10;                .retrieve()&#10;                .toBodilessEntity()&#10;                .block();&#10;    }&#10;&#10;    private void eliminarUsuarioEnKeycloak(String userId, String token) {&#10;        webClient.delete()&#10;                .uri(&quot;/admin/realms/tesina/users/{id}&quot;, userId)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .retrieve()&#10;                .toBodilessEntity()&#10;                .block();&#10;    }&#10;&#10;    private String obtenerUserId(String username, String token) {&#10;        List&lt;Map&lt;String, Object&gt;&gt; body = webClient.get()&#10;                .uri(&quot;/admin/realms/tesina/users?username={username}&quot;, username)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .retrieve()&#10;                .bodyToFlux(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {})&#10;                .collectList()&#10;                .block();&#10;&#10;        if (body == null || body.isEmpty()) return null;&#10;        if (body.size() &gt; 1) throw new RuntimeException(&quot;Más de un usuario encontrado: &quot; + username);&#10;&#10;        return (String) body.get(0).get(&quot;id&quot;);&#10;    }&#10;&#10;    @Transactional&#10;    public ResponseEntity&lt;String&gt; eliminarUsuario(String username) {&#10;        String token = keycloakAdminService.getAdminToken();&#10;        try {&#10;            String userId = obtenerUserId(username, token);&#10;            if (userId == null) {&#10;                return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                        .body(&quot;Usuario no encontrado en Keycloak: &quot; + username);&#10;            }&#10;&#10;            Optional&lt;Usuario&gt; backup = usuarioRepository.findById(UUID.fromString(userId));&#10;&#10;            // Eliminar de Postgres&#10;            usuarioRepository.deleteById(UUID.fromString(userId));&#10;&#10;            try {&#10;                eliminarUsuarioEnKeycloak(userId, token);&#10;            } catch (Exception e) {&#10;                // rollback en Postgres&#10;                backup.ifPresent(usuarioRepository::save);&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                        .body(&quot;Fallo en Keycloak, usuario restaurado en Postgres&quot;);&#10;            }&#10;&#10;            return ResponseEntity.ok(&quot;Usuario eliminado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Error al eliminar usuario: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void asignarRol(String userId, String roleName, String token) {&#10;        Map&lt;String, Object&gt; role = webClient.get()&#10;                .uri(&quot;/admin/realms/tesina/roles/{roleName}&quot;, roleName)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .retrieve()&#10;                .bodyToMono(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {})&#10;                .block();&#10;&#10;        if (role == null) throw new RuntimeException(&quot;Rol no encontrado: &quot; + roleName);&#10;&#10;        webClient.post()&#10;                .uri(&quot;/admin/realms/tesina/users/{userId}/role-mappings/realm&quot;, userId)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .bodyValue(List.of(role))&#10;                .retrieve()&#10;                .toBodilessEntity()&#10;                .block();&#10;    }&#10;&#10;&#10;    public ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; listarUsuarios() {&#10;        String token = keycloakAdminService.getAdminToken();&#10;        try {&#10;            List&lt;Map&lt;String, Object&gt;&gt; users = webClient.get()&#10;                    .uri(&quot;/admin/realms/tesina/users&quot;)&#10;                    .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                    .retrieve()&#10;                    .bodyToFlux(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {})&#10;                    .collectList()&#10;                    .block();&#10;&#10;            if (users == null) {&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                        .body(Collections.emptyList());&#10;            }&#10;&#10;            return ResponseEntity.ok(users);&#10;&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Collections.emptyList());&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package org.paper.services;&#10;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;import org.paper.DTO.UsuarioDTO;&#10;import org.paper.entity.Usuario;&#10;import org.paper.repository.UsuarioRepository;&#10;import org.springframework.core.ParameterizedTypeReference;&#10;import org.springframework.http.*;&#10;import org.springframework.stereotype.Service;&#10;import org.springframework.transaction.annotation.Transactional;&#10;import org.springframework.web.reactive.function.client.WebClient;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.*;&#10;&#10;@Slf4j&#10;@Service&#10;public class UsuarioService {&#10;&#10;    private final KeycloakAdminService keycloakAdminService;&#10;    private final UsuarioRepository usuarioRepository;&#10;    private final WebClient webClient;&#10;&#10;    public UsuarioService(KeycloakAdminService keycloakAdminService,&#10;                          UsuarioRepository usuarioRepository,&#10;                          WebClient webClient) {&#10;        this.keycloakAdminService = keycloakAdminService;&#10;        this.usuarioRepository = usuarioRepository;&#10;        this.webClient = webClient;&#10;    }&#10;&#10;    @Transactional&#10;    public ResponseEntity&lt;String&gt; crearUsuario(UsuarioDTO usuario) {&#10;        String token = keycloakAdminService.getAdminToken();&#10;        String userId = null;&#10;&#10;        try {&#10;            // 1. Crear usuario en Keycloak&#10;            String jsonBody = String.format(&#10;                    &quot;{ \&quot;username\&quot;:\&quot;%s\&quot;, \&quot;enabled\&quot;:%b, \&quot;firstName\&quot;:\&quot;%s\&quot;, \&quot;lastName\&quot;:\&quot;%s\&quot;, \&quot;email\&quot;:\&quot;%s\&quot;, \&quot;emailVerified\&quot;:%b }&quot;,&#10;                    usuario.getUsername(),&#10;                    usuario.isEnabled(),&#10;                    usuario.getFirstName(),&#10;                    usuario.getLastName(),&#10;                    usuario.getEmail(),&#10;                    usuario.isEmailVerified()&#10;            );&#10;&#10;            ResponseEntity&lt;String&gt; response = webClient.post()&#10;                    .uri(&quot;/admin/realms/tesina/users&quot;)&#10;                    .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                    .contentType(MediaType.APPLICATION_JSON)&#10;                    .bodyValue(jsonBody)&#10;                    .retrieve()&#10;                    .toEntity(String.class)&#10;                    .block();&#10;&#10;            if (response.getStatusCode().is2xxSuccessful()) {&#10;                // 2. Obtener UUID&#10;                userId = obtenerUserId(usuario.getUsername(), token);&#10;                if (userId == null) throw new RuntimeException(&quot;No se pudo obtener el UUID de Keycloak&quot;);&#10;&#10;                // 3. Asignar password&#10;                if (usuario.getPassword() != null) {&#10;                    try {&#10;                        asignarPassword(usuario, token, userId);&#10;                    } catch (Exception e) {&#10;                        eliminarUsuarioEnKeycloak(userId, token);&#10;                        throw new RuntimeException(&quot;Fallo asignando password: &quot; + e.getMessage());&#10;                    }&#10;                }&#10;&#10;                // 4. Guardar en Postgres (protegido por @Transactional)&#10;                Usuario entity = new Usuario();&#10;                entity.setId(UUID.fromString(userId));&#10;                entity.setFechaRegistro(LocalDateTime.now());&#10;                usuarioRepository.save(entity);&#10;&#10;                // 5. Asignar rol por defecto (INTERESADO)&#10;                try {&#10;                    asignarRol(userId, &quot;INTERESADO&quot;, token);&#10;                } catch (Exception e) {&#10;                    eliminarUsuarioEnKeycloak(userId, token);&#10;                    throw new RuntimeException(&quot;Fallo asignando rol: &quot; + e.getMessage());&#10;                }&#10;&#10;            } else {&#10;                throw new RuntimeException(&quot;Error al crear usuario en Keycloak: &quot; + response.getStatusCode());&#10;            }&#10;&#10;            return ResponseEntity.ok(&quot;Usuario creado correctamente&quot;);&#10;&#10;        } catch (Exception e) {&#10;            if (userId != null) {&#10;                eliminarUsuarioEnKeycloak(userId, token);&#10;            }&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Error al crear usuario: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void asignarPassword(UsuarioDTO usuario, String token, String userId) {&#10;        String passwordJson = String.format(&quot;{\&quot;type\&quot;:\&quot;password\&quot;,\&quot;value\&quot;:\&quot;%s\&quot;,\&quot;temporary\&quot;:false}&quot;, usuario.getPassword());&#10;&#10;        webClient.put()&#10;                .uri(&quot;/admin/realms/tesina/users/{id}/reset-password&quot;, userId)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .contentType(MediaType.APPLICATION_JSON)&#10;                .bodyValue(passwordJson)&#10;                .retrieve()&#10;                .toBodilessEntity()&#10;                .block();&#10;    }&#10;&#10;    private void eliminarUsuarioEnKeycloak(String userId, String token) {&#10;        webClient.delete()&#10;                .uri(&quot;/admin/realms/tesina/users/{id}&quot;, userId)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .retrieve()&#10;                .toBodilessEntity()&#10;                .block();&#10;    }&#10;&#10;    private String obtenerUserId(String username, String token) {&#10;        List&lt;Map&lt;String, Object&gt;&gt; body = webClient.get()&#10;                .uri(&quot;/admin/realms/tesina/users?username={username}&quot;, username)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .retrieve()&#10;                .bodyToFlux(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {})&#10;                .collectList()&#10;                .block();&#10;&#10;        if (body == null || body.isEmpty()) return null;&#10;        if (body.size() &gt; 1) throw new RuntimeException(&quot;Más de un usuario encontrado: &quot; + username);&#10;&#10;        return (String) body.get(0).get(&quot;id&quot;);&#10;    }&#10;&#10;    @Transactional&#10;    public ResponseEntity&lt;String&gt; eliminarUsuario(String username) {&#10;        String token = keycloakAdminService.getAdminToken();&#10;        try {&#10;            String userId = obtenerUserId(username, token);&#10;            if (userId == null) {&#10;                return ResponseEntity.status(HttpStatus.NOT_FOUND)&#10;                        .body(&quot;Usuario no encontrado en Keycloak: &quot; + username);&#10;            }&#10;&#10;            Optional&lt;Usuario&gt; backup = usuarioRepository.findById(UUID.fromString(userId));&#10;&#10;            // Eliminar de Postgres&#10;            usuarioRepository.deleteById(UUID.fromString(userId));&#10;&#10;            try {&#10;                eliminarUsuarioEnKeycloak(userId, token);&#10;            } catch (Exception e) {&#10;                // rollback en Postgres&#10;                backup.ifPresent(usuarioRepository::save);&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                        .body(&quot;Fallo en Keycloak, usuario restaurado en Postgres&quot;);&#10;            }&#10;&#10;            return ResponseEntity.ok(&quot;Usuario eliminado correctamente&quot;);&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(&quot;Error al eliminar usuario: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    private void asignarRol(String userId, String roleName, String token) {&#10;        Map&lt;String, Object&gt; role = webClient.get()&#10;                .uri(&quot;/admin/realms/tesina/roles/{roleName}&quot;, roleName)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .retrieve()&#10;                .bodyToMono(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {})&#10;                .block();&#10;&#10;        if (role == null) throw new RuntimeException(&quot;Rol no encontrado: &quot; + roleName);&#10;&#10;        webClient.post()&#10;                .uri(&quot;/admin/realms/tesina/users/{userId}/role-mappings/realm&quot;, userId)&#10;                .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                .bodyValue(List.of(role))&#10;                .retrieve()&#10;                .toBodilessEntity()&#10;                .block();&#10;    }&#10;&#10;&#10;    public ResponseEntity&lt;List&lt;Map&lt;String, Object&gt;&gt;&gt; listarUsuarios() {&#10;        String token = keycloakAdminService.getAdminToken();&#10;        try {&#10;            List&lt;Map&lt;String, Object&gt;&gt; users = webClient.get()&#10;                    .uri(&quot;/admin/realms/tesina/users&quot;)&#10;                    .header(HttpHeaders.AUTHORIZATION, &quot;Bearer &quot; + token)&#10;                    .retrieve()&#10;                    .bodyToFlux(new ParameterizedTypeReference&lt;Map&lt;String, Object&gt;&gt;() {})&#10;                    .collectList()&#10;                    .block();&#10;&#10;            if (users == null) {&#10;                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                        .body(Collections.emptyList());&#10;            }&#10;&#10;            return ResponseEntity.ok(users);&#10;&#10;        } catch (Exception e) {&#10;            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)&#10;                    .body(Collections.emptyList());&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>